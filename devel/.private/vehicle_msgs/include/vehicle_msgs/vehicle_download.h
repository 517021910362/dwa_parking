// Generated by gencpp from file vehicle_msgs/vehicle_download.msg
// DO NOT EDIT!


#ifndef VEHICLE_MSGS_MESSAGE_VEHICLE_DOWNLOAD_H
#define VEHICLE_MSGS_MESSAGE_VEHICLE_DOWNLOAD_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace vehicle_msgs
{
template <class ContainerAllocator>
struct vehicle_download_
{
  typedef vehicle_download_<ContainerAllocator> Type;

  vehicle_download_()
    : TarAccler(0.0)
    , Tar_steerangle(0.0)
    , Tar_gear(0)
    , DiveoffReq(0)
    , ADS_mode(0)
    , Stoprequest(0)
    , EndOfTravel(0)
    , Station_In_Out(0)
    , TurnSignal(0)
    , DoubleLight(0)
    , HummerSts(0)
    , latAcceleration(0.0)
    , longAcceleration(0.0)
    , Acceleration(0.0)
    , Yaw_rate(0.0)
    , Slope(0.0)  {
    }
  vehicle_download_(const ContainerAllocator& _alloc)
    : TarAccler(0.0)
    , Tar_steerangle(0.0)
    , Tar_gear(0)
    , DiveoffReq(0)
    , ADS_mode(0)
    , Stoprequest(0)
    , EndOfTravel(0)
    , Station_In_Out(0)
    , TurnSignal(0)
    , DoubleLight(0)
    , HummerSts(0)
    , latAcceleration(0.0)
    , longAcceleration(0.0)
    , Acceleration(0.0)
    , Yaw_rate(0.0)
    , Slope(0.0)  {
  (void)_alloc;
    }



   typedef float _TarAccler_type;
  _TarAccler_type TarAccler;

   typedef float _Tar_steerangle_type;
  _Tar_steerangle_type Tar_steerangle;

   typedef uint8_t _Tar_gear_type;
  _Tar_gear_type Tar_gear;

   typedef uint8_t _DiveoffReq_type;
  _DiveoffReq_type DiveoffReq;

   typedef uint8_t _ADS_mode_type;
  _ADS_mode_type ADS_mode;

   typedef uint8_t _Stoprequest_type;
  _Stoprequest_type Stoprequest;

   typedef uint8_t _EndOfTravel_type;
  _EndOfTravel_type EndOfTravel;

   typedef uint8_t _Station_In_Out_type;
  _Station_In_Out_type Station_In_Out;

   typedef uint8_t _TurnSignal_type;
  _TurnSignal_type TurnSignal;

   typedef uint8_t _DoubleLight_type;
  _DoubleLight_type DoubleLight;

   typedef uint8_t _HummerSts_type;
  _HummerSts_type HummerSts;

   typedef float _latAcceleration_type;
  _latAcceleration_type latAcceleration;

   typedef float _longAcceleration_type;
  _longAcceleration_type longAcceleration;

   typedef float _Acceleration_type;
  _Acceleration_type Acceleration;

   typedef float _Yaw_rate_type;
  _Yaw_rate_type Yaw_rate;

   typedef float _Slope_type;
  _Slope_type Slope;





  typedef boost::shared_ptr< ::vehicle_msgs::vehicle_download_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::vehicle_msgs::vehicle_download_<ContainerAllocator> const> ConstPtr;

}; // struct vehicle_download_

typedef ::vehicle_msgs::vehicle_download_<std::allocator<void> > vehicle_download;

typedef boost::shared_ptr< ::vehicle_msgs::vehicle_download > vehicle_downloadPtr;
typedef boost::shared_ptr< ::vehicle_msgs::vehicle_download const> vehicle_downloadConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::vehicle_msgs::vehicle_download_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::vehicle_msgs::vehicle_download_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::vehicle_msgs::vehicle_download_<ContainerAllocator1> & lhs, const ::vehicle_msgs::vehicle_download_<ContainerAllocator2> & rhs)
{
  return lhs.TarAccler == rhs.TarAccler &&
    lhs.Tar_steerangle == rhs.Tar_steerangle &&
    lhs.Tar_gear == rhs.Tar_gear &&
    lhs.DiveoffReq == rhs.DiveoffReq &&
    lhs.ADS_mode == rhs.ADS_mode &&
    lhs.Stoprequest == rhs.Stoprequest &&
    lhs.EndOfTravel == rhs.EndOfTravel &&
    lhs.Station_In_Out == rhs.Station_In_Out &&
    lhs.TurnSignal == rhs.TurnSignal &&
    lhs.DoubleLight == rhs.DoubleLight &&
    lhs.HummerSts == rhs.HummerSts &&
    lhs.latAcceleration == rhs.latAcceleration &&
    lhs.longAcceleration == rhs.longAcceleration &&
    lhs.Acceleration == rhs.Acceleration &&
    lhs.Yaw_rate == rhs.Yaw_rate &&
    lhs.Slope == rhs.Slope;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::vehicle_msgs::vehicle_download_<ContainerAllocator1> & lhs, const ::vehicle_msgs::vehicle_download_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace vehicle_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::vehicle_msgs::vehicle_download_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::vehicle_msgs::vehicle_download_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::vehicle_msgs::vehicle_download_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::vehicle_msgs::vehicle_download_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::vehicle_msgs::vehicle_download_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::vehicle_msgs::vehicle_download_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::vehicle_msgs::vehicle_download_<ContainerAllocator> >
{
  static const char* value()
  {
    return "b1c7accc64c1d758d5af51e3905238ba";
  }

  static const char* value(const ::vehicle_msgs::vehicle_download_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xb1c7accc64c1d758ULL;
  static const uint64_t static_value2 = 0xd5af51e3905238baULL;
};

template<class ContainerAllocator>
struct DataType< ::vehicle_msgs::vehicle_download_<ContainerAllocator> >
{
  static const char* value()
  {
    return "vehicle_msgs/vehicle_download";
  }

  static const char* value(const ::vehicle_msgs::vehicle_download_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::vehicle_msgs::vehicle_download_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 TarAccler\n"
"float32 Tar_steerangle\n"
"uint8 Tar_gear\n"
"uint8 DiveoffReq\n"
"uint8 ADS_mode\n"
"uint8 Stoprequest\n"
"uint8 EndOfTravel\n"
"uint8 Station_In_Out\n"
"uint8 TurnSignal\n"
"uint8 DoubleLight\n"
"uint8 HummerSts\n"
"float32 latAcceleration\n"
"float32 longAcceleration\n"
"float32 Acceleration\n"
"float32 Yaw_rate\n"
"float32 Slope\n"
;
  }

  static const char* value(const ::vehicle_msgs::vehicle_download_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::vehicle_msgs::vehicle_download_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.TarAccler);
      stream.next(m.Tar_steerangle);
      stream.next(m.Tar_gear);
      stream.next(m.DiveoffReq);
      stream.next(m.ADS_mode);
      stream.next(m.Stoprequest);
      stream.next(m.EndOfTravel);
      stream.next(m.Station_In_Out);
      stream.next(m.TurnSignal);
      stream.next(m.DoubleLight);
      stream.next(m.HummerSts);
      stream.next(m.latAcceleration);
      stream.next(m.longAcceleration);
      stream.next(m.Acceleration);
      stream.next(m.Yaw_rate);
      stream.next(m.Slope);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct vehicle_download_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::vehicle_msgs::vehicle_download_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::vehicle_msgs::vehicle_download_<ContainerAllocator>& v)
  {
    s << indent << "TarAccler: ";
    Printer<float>::stream(s, indent + "  ", v.TarAccler);
    s << indent << "Tar_steerangle: ";
    Printer<float>::stream(s, indent + "  ", v.Tar_steerangle);
    s << indent << "Tar_gear: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Tar_gear);
    s << indent << "DiveoffReq: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.DiveoffReq);
    s << indent << "ADS_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ADS_mode);
    s << indent << "Stoprequest: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Stoprequest);
    s << indent << "EndOfTravel: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.EndOfTravel);
    s << indent << "Station_In_Out: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Station_In_Out);
    s << indent << "TurnSignal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.TurnSignal);
    s << indent << "DoubleLight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.DoubleLight);
    s << indent << "HummerSts: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.HummerSts);
    s << indent << "latAcceleration: ";
    Printer<float>::stream(s, indent + "  ", v.latAcceleration);
    s << indent << "longAcceleration: ";
    Printer<float>::stream(s, indent + "  ", v.longAcceleration);
    s << indent << "Acceleration: ";
    Printer<float>::stream(s, indent + "  ", v.Acceleration);
    s << indent << "Yaw_rate: ";
    Printer<float>::stream(s, indent + "  ", v.Yaw_rate);
    s << indent << "Slope: ";
    Printer<float>::stream(s, indent + "  ", v.Slope);
  }
};

} // namespace message_operations
} // namespace ros

#endif // VEHICLE_MSGS_MESSAGE_VEHICLE_DOWNLOAD_H
