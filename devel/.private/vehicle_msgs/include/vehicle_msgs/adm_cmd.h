// Generated by gencpp from file vehicle_msgs/adm_cmd.msg
// DO NOT EDIT!


#ifndef VEHICLE_MSGS_MESSAGE_ADM_CMD_H
#define VEHICLE_MSGS_MESSAGE_ADM_CMD_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace vehicle_msgs
{
template <class ContainerAllocator>
struct adm_cmd_
{
  typedef adm_cmd_<ContainerAllocator> Type;

  adm_cmd_()
    : AccPed(0)
    , AccPed_enable(0)
    , ADM_FaultLevel(0)
    , Fog_Light(0)
    , Horn(0)
    , Hydraulic_Brake(0)
    , High_BeamLigh(0)
    , Low_BeamLight(0)
    , Turn_Signal(0)
    , Double_Light(0)
    , Night_Light(0)
    , Defroster_Control(0)
    , Wiper_Control(0)
    , Amble_Brake(0)
    , Compartment_Control(0)
    , Emergency_Brake(0)
    , Load_Brake(0)
    , Engine_Start(0)
    , Engine_Stop(0)
    , Road_DryorWet(0)
    , Switch_DynamicorEconomical(0)
    , Slope(0)
    , Gear(0)
    , GPS1_Curvature_cmd(0.0)
    , finish_over(0)  {
    }
  adm_cmd_(const ContainerAllocator& _alloc)
    : AccPed(0)
    , AccPed_enable(0)
    , ADM_FaultLevel(0)
    , Fog_Light(0)
    , Horn(0)
    , Hydraulic_Brake(0)
    , High_BeamLigh(0)
    , Low_BeamLight(0)
    , Turn_Signal(0)
    , Double_Light(0)
    , Night_Light(0)
    , Defroster_Control(0)
    , Wiper_Control(0)
    , Amble_Brake(0)
    , Compartment_Control(0)
    , Emergency_Brake(0)
    , Load_Brake(0)
    , Engine_Start(0)
    , Engine_Stop(0)
    , Road_DryorWet(0)
    , Switch_DynamicorEconomical(0)
    , Slope(0)
    , Gear(0)
    , GPS1_Curvature_cmd(0.0)
    , finish_over(0)  {
  (void)_alloc;
    }



   typedef uint8_t _AccPed_type;
  _AccPed_type AccPed;

   typedef uint8_t _AccPed_enable_type;
  _AccPed_enable_type AccPed_enable;

   typedef uint8_t _ADM_FaultLevel_type;
  _ADM_FaultLevel_type ADM_FaultLevel;

   typedef uint8_t _Fog_Light_type;
  _Fog_Light_type Fog_Light;

   typedef uint8_t _Horn_type;
  _Horn_type Horn;

   typedef uint8_t _Hydraulic_Brake_type;
  _Hydraulic_Brake_type Hydraulic_Brake;

   typedef uint8_t _High_BeamLigh_type;
  _High_BeamLigh_type High_BeamLigh;

   typedef uint8_t _Low_BeamLight_type;
  _Low_BeamLight_type Low_BeamLight;

   typedef uint8_t _Turn_Signal_type;
  _Turn_Signal_type Turn_Signal;

   typedef uint8_t _Double_Light_type;
  _Double_Light_type Double_Light;

   typedef uint8_t _Night_Light_type;
  _Night_Light_type Night_Light;

   typedef uint8_t _Defroster_Control_type;
  _Defroster_Control_type Defroster_Control;

   typedef uint8_t _Wiper_Control_type;
  _Wiper_Control_type Wiper_Control;

   typedef uint8_t _Amble_Brake_type;
  _Amble_Brake_type Amble_Brake;

   typedef uint8_t _Compartment_Control_type;
  _Compartment_Control_type Compartment_Control;

   typedef uint8_t _Emergency_Brake_type;
  _Emergency_Brake_type Emergency_Brake;

   typedef uint8_t _Load_Brake_type;
  _Load_Brake_type Load_Brake;

   typedef uint8_t _Engine_Start_type;
  _Engine_Start_type Engine_Start;

   typedef uint8_t _Engine_Stop_type;
  _Engine_Stop_type Engine_Stop;

   typedef uint8_t _Road_DryorWet_type;
  _Road_DryorWet_type Road_DryorWet;

   typedef uint8_t _Switch_DynamicorEconomical_type;
  _Switch_DynamicorEconomical_type Switch_DynamicorEconomical;

   typedef uint8_t _Slope_type;
  _Slope_type Slope;

   typedef uint8_t _Gear_type;
  _Gear_type Gear;

   typedef float _GPS1_Curvature_cmd_type;
  _GPS1_Curvature_cmd_type GPS1_Curvature_cmd;

   typedef uint8_t _finish_over_type;
  _finish_over_type finish_over;





  typedef boost::shared_ptr< ::vehicle_msgs::adm_cmd_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::vehicle_msgs::adm_cmd_<ContainerAllocator> const> ConstPtr;

}; // struct adm_cmd_

typedef ::vehicle_msgs::adm_cmd_<std::allocator<void> > adm_cmd;

typedef boost::shared_ptr< ::vehicle_msgs::adm_cmd > adm_cmdPtr;
typedef boost::shared_ptr< ::vehicle_msgs::adm_cmd const> adm_cmdConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::vehicle_msgs::adm_cmd_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::vehicle_msgs::adm_cmd_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::vehicle_msgs::adm_cmd_<ContainerAllocator1> & lhs, const ::vehicle_msgs::adm_cmd_<ContainerAllocator2> & rhs)
{
  return lhs.AccPed == rhs.AccPed &&
    lhs.AccPed_enable == rhs.AccPed_enable &&
    lhs.ADM_FaultLevel == rhs.ADM_FaultLevel &&
    lhs.Fog_Light == rhs.Fog_Light &&
    lhs.Horn == rhs.Horn &&
    lhs.Hydraulic_Brake == rhs.Hydraulic_Brake &&
    lhs.High_BeamLigh == rhs.High_BeamLigh &&
    lhs.Low_BeamLight == rhs.Low_BeamLight &&
    lhs.Turn_Signal == rhs.Turn_Signal &&
    lhs.Double_Light == rhs.Double_Light &&
    lhs.Night_Light == rhs.Night_Light &&
    lhs.Defroster_Control == rhs.Defroster_Control &&
    lhs.Wiper_Control == rhs.Wiper_Control &&
    lhs.Amble_Brake == rhs.Amble_Brake &&
    lhs.Compartment_Control == rhs.Compartment_Control &&
    lhs.Emergency_Brake == rhs.Emergency_Brake &&
    lhs.Load_Brake == rhs.Load_Brake &&
    lhs.Engine_Start == rhs.Engine_Start &&
    lhs.Engine_Stop == rhs.Engine_Stop &&
    lhs.Road_DryorWet == rhs.Road_DryorWet &&
    lhs.Switch_DynamicorEconomical == rhs.Switch_DynamicorEconomical &&
    lhs.Slope == rhs.Slope &&
    lhs.Gear == rhs.Gear &&
    lhs.GPS1_Curvature_cmd == rhs.GPS1_Curvature_cmd &&
    lhs.finish_over == rhs.finish_over;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::vehicle_msgs::adm_cmd_<ContainerAllocator1> & lhs, const ::vehicle_msgs::adm_cmd_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace vehicle_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::vehicle_msgs::adm_cmd_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::vehicle_msgs::adm_cmd_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::vehicle_msgs::adm_cmd_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::vehicle_msgs::adm_cmd_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::vehicle_msgs::adm_cmd_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::vehicle_msgs::adm_cmd_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::vehicle_msgs::adm_cmd_<ContainerAllocator> >
{
  static const char* value()
  {
    return "03c23fc13499203340068a71426d1dfc";
  }

  static const char* value(const ::vehicle_msgs::adm_cmd_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x03c23fc134992033ULL;
  static const uint64_t static_value2 = 0x40068a71426d1dfcULL;
};

template<class ContainerAllocator>
struct DataType< ::vehicle_msgs::adm_cmd_<ContainerAllocator> >
{
  static const char* value()
  {
    return "vehicle_msgs/adm_cmd";
  }

  static const char* value(const ::vehicle_msgs::adm_cmd_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::vehicle_msgs::adm_cmd_<ContainerAllocator> >
{
  static const char* value()
  {
    return "uint8 AccPed\n"
"uint8 AccPed_enable\n"
"uint8 ADM_FaultLevel\n"
"uint8 Fog_Light\n"
"uint8 Horn\n"
"uint8 Hydraulic_Brake\n"
"uint8 High_BeamLigh\n"
"uint8 Low_BeamLight\n"
"uint8 Turn_Signal\n"
"uint8 Double_Light\n"
"\n"
"uint8 Night_Light\n"
"uint8 Defroster_Control\n"
"uint8 Wiper_Control\n"
"uint8 Amble_Brake\n"
"uint8 Compartment_Control\n"
"uint8 Emergency_Brake\n"
"uint8 Load_Brake\n"
"uint8 Engine_Start\n"
"uint8 Engine_Stop\n"
"uint8 Road_DryorWet\n"
"uint8 Switch_DynamicorEconomical\n"
"uint8 Slope\n"
"uint8 Gear\n"
"float32 GPS1_Curvature_cmd\n"
"uint8 finish_over\n"
"\n"
;
  }

  static const char* value(const ::vehicle_msgs::adm_cmd_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::vehicle_msgs::adm_cmd_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.AccPed);
      stream.next(m.AccPed_enable);
      stream.next(m.ADM_FaultLevel);
      stream.next(m.Fog_Light);
      stream.next(m.Horn);
      stream.next(m.Hydraulic_Brake);
      stream.next(m.High_BeamLigh);
      stream.next(m.Low_BeamLight);
      stream.next(m.Turn_Signal);
      stream.next(m.Double_Light);
      stream.next(m.Night_Light);
      stream.next(m.Defroster_Control);
      stream.next(m.Wiper_Control);
      stream.next(m.Amble_Brake);
      stream.next(m.Compartment_Control);
      stream.next(m.Emergency_Brake);
      stream.next(m.Load_Brake);
      stream.next(m.Engine_Start);
      stream.next(m.Engine_Stop);
      stream.next(m.Road_DryorWet);
      stream.next(m.Switch_DynamicorEconomical);
      stream.next(m.Slope);
      stream.next(m.Gear);
      stream.next(m.GPS1_Curvature_cmd);
      stream.next(m.finish_over);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct adm_cmd_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::vehicle_msgs::adm_cmd_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::vehicle_msgs::adm_cmd_<ContainerAllocator>& v)
  {
    s << indent << "AccPed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.AccPed);
    s << indent << "AccPed_enable: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.AccPed_enable);
    s << indent << "ADM_FaultLevel: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.ADM_FaultLevel);
    s << indent << "Fog_Light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Fog_Light);
    s << indent << "Horn: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Horn);
    s << indent << "Hydraulic_Brake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Hydraulic_Brake);
    s << indent << "High_BeamLigh: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.High_BeamLigh);
    s << indent << "Low_BeamLight: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Low_BeamLight);
    s << indent << "Turn_Signal: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Turn_Signal);
    s << indent << "Double_Light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Double_Light);
    s << indent << "Night_Light: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Night_Light);
    s << indent << "Defroster_Control: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Defroster_Control);
    s << indent << "Wiper_Control: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Wiper_Control);
    s << indent << "Amble_Brake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Amble_Brake);
    s << indent << "Compartment_Control: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Compartment_Control);
    s << indent << "Emergency_Brake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Emergency_Brake);
    s << indent << "Load_Brake: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Load_Brake);
    s << indent << "Engine_Start: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Engine_Start);
    s << indent << "Engine_Stop: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Engine_Stop);
    s << indent << "Road_DryorWet: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Road_DryorWet);
    s << indent << "Switch_DynamicorEconomical: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Switch_DynamicorEconomical);
    s << indent << "Slope: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Slope);
    s << indent << "Gear: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Gear);
    s << indent << "GPS1_Curvature_cmd: ";
    Printer<float>::stream(s, indent + "  ", v.GPS1_Curvature_cmd);
    s << indent << "finish_over: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.finish_over);
  }
};

} // namespace message_operations
} // namespace ros

#endif // VEHICLE_MSGS_MESSAGE_ADM_CMD_H
