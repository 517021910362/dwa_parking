// Generated by gencpp from file vehicle_msgs/vehicle_upload.msg
// DO NOT EDIT!


#ifndef VEHICLE_MSGS_MESSAGE_VEHICLE_UPLOAD_H
#define VEHICLE_MSGS_MESSAGE_VEHICLE_UPLOAD_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace vehicle_msgs
{
template <class ContainerAllocator>
struct vehicle_upload_
{
  typedef vehicle_upload_<ContainerAllocator> Type;

  vehicle_upload_()
    : Vehicle_speed(0.0)
    , Vehicle_speedQuality(0.0)
    , EPS_SteerAng(0.0)
    , EPS_SteerAngQuality(0.0)
    , BMS_BattSOC(0.0)
    , BMS_BattSOCQuality(0.0)
    , Tar_gearFeed(0)
    , Tar_gearFeedQuality(0)
    , Drive_Mode(0)  {
    }
  vehicle_upload_(const ContainerAllocator& _alloc)
    : Vehicle_speed(0.0)
    , Vehicle_speedQuality(0.0)
    , EPS_SteerAng(0.0)
    , EPS_SteerAngQuality(0.0)
    , BMS_BattSOC(0.0)
    , BMS_BattSOCQuality(0.0)
    , Tar_gearFeed(0)
    , Tar_gearFeedQuality(0)
    , Drive_Mode(0)  {
  (void)_alloc;
    }



   typedef float _Vehicle_speed_type;
  _Vehicle_speed_type Vehicle_speed;

   typedef float _Vehicle_speedQuality_type;
  _Vehicle_speedQuality_type Vehicle_speedQuality;

   typedef float _EPS_SteerAng_type;
  _EPS_SteerAng_type EPS_SteerAng;

   typedef float _EPS_SteerAngQuality_type;
  _EPS_SteerAngQuality_type EPS_SteerAngQuality;

   typedef float _BMS_BattSOC_type;
  _BMS_BattSOC_type BMS_BattSOC;

   typedef float _BMS_BattSOCQuality_type;
  _BMS_BattSOCQuality_type BMS_BattSOCQuality;

   typedef uint8_t _Tar_gearFeed_type;
  _Tar_gearFeed_type Tar_gearFeed;

   typedef uint8_t _Tar_gearFeedQuality_type;
  _Tar_gearFeedQuality_type Tar_gearFeedQuality;

   typedef uint8_t _Drive_Mode_type;
  _Drive_Mode_type Drive_Mode;





  typedef boost::shared_ptr< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> const> ConstPtr;

}; // struct vehicle_upload_

typedef ::vehicle_msgs::vehicle_upload_<std::allocator<void> > vehicle_upload;

typedef boost::shared_ptr< ::vehicle_msgs::vehicle_upload > vehicle_uploadPtr;
typedef boost::shared_ptr< ::vehicle_msgs::vehicle_upload const> vehicle_uploadConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::vehicle_msgs::vehicle_upload_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::vehicle_msgs::vehicle_upload_<ContainerAllocator1> & lhs, const ::vehicle_msgs::vehicle_upload_<ContainerAllocator2> & rhs)
{
  return lhs.Vehicle_speed == rhs.Vehicle_speed &&
    lhs.Vehicle_speedQuality == rhs.Vehicle_speedQuality &&
    lhs.EPS_SteerAng == rhs.EPS_SteerAng &&
    lhs.EPS_SteerAngQuality == rhs.EPS_SteerAngQuality &&
    lhs.BMS_BattSOC == rhs.BMS_BattSOC &&
    lhs.BMS_BattSOCQuality == rhs.BMS_BattSOCQuality &&
    lhs.Tar_gearFeed == rhs.Tar_gearFeed &&
    lhs.Tar_gearFeedQuality == rhs.Tar_gearFeedQuality &&
    lhs.Drive_Mode == rhs.Drive_Mode;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::vehicle_msgs::vehicle_upload_<ContainerAllocator1> & lhs, const ::vehicle_msgs::vehicle_upload_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace vehicle_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsFixedSize< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> >
{
  static const char* value()
  {
    return "dd7e7d66aa61f766087ccedcc5b96655";
  }

  static const char* value(const ::vehicle_msgs::vehicle_upload_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xdd7e7d66aa61f766ULL;
  static const uint64_t static_value2 = 0x087ccedcc5b96655ULL;
};

template<class ContainerAllocator>
struct DataType< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> >
{
  static const char* value()
  {
    return "vehicle_msgs/vehicle_upload";
  }

  static const char* value(const ::vehicle_msgs::vehicle_upload_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> >
{
  static const char* value()
  {
    return "float32 Vehicle_speed\n"
"float32 Vehicle_speedQuality\n"
"float32 EPS_SteerAng\n"
"float32 EPS_SteerAngQuality\n"
"float32 BMS_BattSOC\n"
"float32 BMS_BattSOCQuality\n"
"uint8 Tar_gearFeed\n"
"uint8 Tar_gearFeedQuality\n"
"uint8 Drive_Mode\n"
;
  }

  static const char* value(const ::vehicle_msgs::vehicle_upload_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.Vehicle_speed);
      stream.next(m.Vehicle_speedQuality);
      stream.next(m.EPS_SteerAng);
      stream.next(m.EPS_SteerAngQuality);
      stream.next(m.BMS_BattSOC);
      stream.next(m.BMS_BattSOCQuality);
      stream.next(m.Tar_gearFeed);
      stream.next(m.Tar_gearFeedQuality);
      stream.next(m.Drive_Mode);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct vehicle_upload_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::vehicle_msgs::vehicle_upload_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::vehicle_msgs::vehicle_upload_<ContainerAllocator>& v)
  {
    s << indent << "Vehicle_speed: ";
    Printer<float>::stream(s, indent + "  ", v.Vehicle_speed);
    s << indent << "Vehicle_speedQuality: ";
    Printer<float>::stream(s, indent + "  ", v.Vehicle_speedQuality);
    s << indent << "EPS_SteerAng: ";
    Printer<float>::stream(s, indent + "  ", v.EPS_SteerAng);
    s << indent << "EPS_SteerAngQuality: ";
    Printer<float>::stream(s, indent + "  ", v.EPS_SteerAngQuality);
    s << indent << "BMS_BattSOC: ";
    Printer<float>::stream(s, indent + "  ", v.BMS_BattSOC);
    s << indent << "BMS_BattSOCQuality: ";
    Printer<float>::stream(s, indent + "  ", v.BMS_BattSOCQuality);
    s << indent << "Tar_gearFeed: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Tar_gearFeed);
    s << indent << "Tar_gearFeedQuality: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Tar_gearFeedQuality);
    s << indent << "Drive_Mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.Drive_Mode);
  }
};

} // namespace message_operations
} // namespace ros

#endif // VEHICLE_MSGS_MESSAGE_VEHICLE_UPLOAD_H
