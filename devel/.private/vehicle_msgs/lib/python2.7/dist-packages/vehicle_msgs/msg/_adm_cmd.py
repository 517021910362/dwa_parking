# This Python file uses the following encoding: utf-8
"""autogenerated by genpy from vehicle_msgs/adm_cmd.msg. Do not edit."""
import codecs
import sys
python3 = True if sys.hexversion > 0x03000000 else False
import genpy
import struct


class adm_cmd(genpy.Message):
  _md5sum = "03c23fc13499203340068a71426d1dfc"
  _type = "vehicle_msgs/adm_cmd"
  _has_header = False  # flag to mark the presence of a Header object
  _full_text = """uint8 AccPed
uint8 AccPed_enable
uint8 ADM_FaultLevel
uint8 Fog_Light
uint8 Horn
uint8 Hydraulic_Brake
uint8 High_BeamLigh
uint8 Low_BeamLight
uint8 Turn_Signal
uint8 Double_Light

uint8 Night_Light
uint8 Defroster_Control
uint8 Wiper_Control
uint8 Amble_Brake
uint8 Compartment_Control
uint8 Emergency_Brake
uint8 Load_Brake
uint8 Engine_Start
uint8 Engine_Stop
uint8 Road_DryorWet
uint8 Switch_DynamicorEconomical
uint8 Slope
uint8 Gear
float32 GPS1_Curvature_cmd
uint8 finish_over

"""
  __slots__ = ['AccPed','AccPed_enable','ADM_FaultLevel','Fog_Light','Horn','Hydraulic_Brake','High_BeamLigh','Low_BeamLight','Turn_Signal','Double_Light','Night_Light','Defroster_Control','Wiper_Control','Amble_Brake','Compartment_Control','Emergency_Brake','Load_Brake','Engine_Start','Engine_Stop','Road_DryorWet','Switch_DynamicorEconomical','Slope','Gear','GPS1_Curvature_cmd','finish_over']
  _slot_types = ['uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','uint8','float32','uint8']

  def __init__(self, *args, **kwds):
    """
    Constructor. Any message fields that are implicitly/explicitly
    set to None will be assigned a default value. The recommend
    use is keyword arguments as this is more robust to future message
    changes.  You cannot mix in-order arguments and keyword arguments.

    The available fields are:
       AccPed,AccPed_enable,ADM_FaultLevel,Fog_Light,Horn,Hydraulic_Brake,High_BeamLigh,Low_BeamLight,Turn_Signal,Double_Light,Night_Light,Defroster_Control,Wiper_Control,Amble_Brake,Compartment_Control,Emergency_Brake,Load_Brake,Engine_Start,Engine_Stop,Road_DryorWet,Switch_DynamicorEconomical,Slope,Gear,GPS1_Curvature_cmd,finish_over

    :param args: complete set of field values, in .msg order
    :param kwds: use keyword arguments corresponding to message field names
    to set specific fields.
    """
    if args or kwds:
      super(adm_cmd, self).__init__(*args, **kwds)
      # message fields cannot be None, assign default values for those that are
      if self.AccPed is None:
        self.AccPed = 0
      if self.AccPed_enable is None:
        self.AccPed_enable = 0
      if self.ADM_FaultLevel is None:
        self.ADM_FaultLevel = 0
      if self.Fog_Light is None:
        self.Fog_Light = 0
      if self.Horn is None:
        self.Horn = 0
      if self.Hydraulic_Brake is None:
        self.Hydraulic_Brake = 0
      if self.High_BeamLigh is None:
        self.High_BeamLigh = 0
      if self.Low_BeamLight is None:
        self.Low_BeamLight = 0
      if self.Turn_Signal is None:
        self.Turn_Signal = 0
      if self.Double_Light is None:
        self.Double_Light = 0
      if self.Night_Light is None:
        self.Night_Light = 0
      if self.Defroster_Control is None:
        self.Defroster_Control = 0
      if self.Wiper_Control is None:
        self.Wiper_Control = 0
      if self.Amble_Brake is None:
        self.Amble_Brake = 0
      if self.Compartment_Control is None:
        self.Compartment_Control = 0
      if self.Emergency_Brake is None:
        self.Emergency_Brake = 0
      if self.Load_Brake is None:
        self.Load_Brake = 0
      if self.Engine_Start is None:
        self.Engine_Start = 0
      if self.Engine_Stop is None:
        self.Engine_Stop = 0
      if self.Road_DryorWet is None:
        self.Road_DryorWet = 0
      if self.Switch_DynamicorEconomical is None:
        self.Switch_DynamicorEconomical = 0
      if self.Slope is None:
        self.Slope = 0
      if self.Gear is None:
        self.Gear = 0
      if self.GPS1_Curvature_cmd is None:
        self.GPS1_Curvature_cmd = 0.
      if self.finish_over is None:
        self.finish_over = 0
    else:
      self.AccPed = 0
      self.AccPed_enable = 0
      self.ADM_FaultLevel = 0
      self.Fog_Light = 0
      self.Horn = 0
      self.Hydraulic_Brake = 0
      self.High_BeamLigh = 0
      self.Low_BeamLight = 0
      self.Turn_Signal = 0
      self.Double_Light = 0
      self.Night_Light = 0
      self.Defroster_Control = 0
      self.Wiper_Control = 0
      self.Amble_Brake = 0
      self.Compartment_Control = 0
      self.Emergency_Brake = 0
      self.Load_Brake = 0
      self.Engine_Start = 0
      self.Engine_Stop = 0
      self.Road_DryorWet = 0
      self.Switch_DynamicorEconomical = 0
      self.Slope = 0
      self.Gear = 0
      self.GPS1_Curvature_cmd = 0.
      self.finish_over = 0

  def _get_types(self):
    """
    internal API method
    """
    return self._slot_types

  def serialize(self, buff):
    """
    serialize message into buffer
    :param buff: buffer, ``StringIO``
    """
    try:
      _x = self
      buff.write(_get_struct_23BfB().pack(_x.AccPed, _x.AccPed_enable, _x.ADM_FaultLevel, _x.Fog_Light, _x.Horn, _x.Hydraulic_Brake, _x.High_BeamLigh, _x.Low_BeamLight, _x.Turn_Signal, _x.Double_Light, _x.Night_Light, _x.Defroster_Control, _x.Wiper_Control, _x.Amble_Brake, _x.Compartment_Control, _x.Emergency_Brake, _x.Load_Brake, _x.Engine_Start, _x.Engine_Stop, _x.Road_DryorWet, _x.Switch_DynamicorEconomical, _x.Slope, _x.Gear, _x.GPS1_Curvature_cmd, _x.finish_over))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize(self, str):
    """
    unpack serialized message in str into this message instance
    :param str: byte array of serialized message, ``str``
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 28
      (_x.AccPed, _x.AccPed_enable, _x.ADM_FaultLevel, _x.Fog_Light, _x.Horn, _x.Hydraulic_Brake, _x.High_BeamLigh, _x.Low_BeamLight, _x.Turn_Signal, _x.Double_Light, _x.Night_Light, _x.Defroster_Control, _x.Wiper_Control, _x.Amble_Brake, _x.Compartment_Control, _x.Emergency_Brake, _x.Load_Brake, _x.Engine_Start, _x.Engine_Stop, _x.Road_DryorWet, _x.Switch_DynamicorEconomical, _x.Slope, _x.Gear, _x.GPS1_Curvature_cmd, _x.finish_over,) = _get_struct_23BfB().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill


  def serialize_numpy(self, buff, numpy):
    """
    serialize message with numpy array types into buffer
    :param buff: buffer, ``StringIO``
    :param numpy: numpy python module
    """
    try:
      _x = self
      buff.write(_get_struct_23BfB().pack(_x.AccPed, _x.AccPed_enable, _x.ADM_FaultLevel, _x.Fog_Light, _x.Horn, _x.Hydraulic_Brake, _x.High_BeamLigh, _x.Low_BeamLight, _x.Turn_Signal, _x.Double_Light, _x.Night_Light, _x.Defroster_Control, _x.Wiper_Control, _x.Amble_Brake, _x.Compartment_Control, _x.Emergency_Brake, _x.Load_Brake, _x.Engine_Start, _x.Engine_Stop, _x.Road_DryorWet, _x.Switch_DynamicorEconomical, _x.Slope, _x.Gear, _x.GPS1_Curvature_cmd, _x.finish_over))
    except struct.error as se: self._check_types(struct.error("%s: '%s' when writing '%s'" % (type(se), str(se), str(locals().get('_x', self)))))
    except TypeError as te: self._check_types(ValueError("%s: '%s' when writing '%s'" % (type(te), str(te), str(locals().get('_x', self)))))

  def deserialize_numpy(self, str, numpy):
    """
    unpack serialized message in str into this message instance using numpy for array types
    :param str: byte array of serialized message, ``str``
    :param numpy: numpy python module
    """
    if python3:
      codecs.lookup_error("rosmsg").msg_type = self._type
    try:
      end = 0
      _x = self
      start = end
      end += 28
      (_x.AccPed, _x.AccPed_enable, _x.ADM_FaultLevel, _x.Fog_Light, _x.Horn, _x.Hydraulic_Brake, _x.High_BeamLigh, _x.Low_BeamLight, _x.Turn_Signal, _x.Double_Light, _x.Night_Light, _x.Defroster_Control, _x.Wiper_Control, _x.Amble_Brake, _x.Compartment_Control, _x.Emergency_Brake, _x.Load_Brake, _x.Engine_Start, _x.Engine_Stop, _x.Road_DryorWet, _x.Switch_DynamicorEconomical, _x.Slope, _x.Gear, _x.GPS1_Curvature_cmd, _x.finish_over,) = _get_struct_23BfB().unpack(str[start:end])
      return self
    except struct.error as e:
      raise genpy.DeserializationError(e)  # most likely buffer underfill

_struct_I = genpy.struct_I
def _get_struct_I():
    global _struct_I
    return _struct_I
_struct_23BfB = None
def _get_struct_23BfB():
    global _struct_23BfB
    if _struct_23BfB is None:
        _struct_23BfB = struct.Struct("<23BfB")
    return _struct_23BfB
